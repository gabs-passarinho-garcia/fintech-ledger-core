#!/usr/bin/env bun

/**
 * Script to generate ECDSA P-256 keys for JWT signing using Node.js crypto.
 * These keys are used for ES256 (ECDSA using P-256 and SHA-256) algorithm.
 */

import { generateKeyPairSync } from 'node:crypto';
import { writeFileSync, mkdirSync, chmodSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

const PROJECT_ROOT = import.meta.dirname + '/..';
const KEYS_DIR = join(PROJECT_ROOT, 'keys');

console.info('üîê Generating ECDSA P-256 keys for JWT signing...\n');

// Create keys directory if it doesn't exist
mkdirSync(KEYS_DIR, { recursive: true });

// Generate key pair
console.info('üìù Generating key pair...');
const { privateKey, publicKey } = generateKeyPairSync('ec', {
  namedCurve: 'prime256v1', // P-256
  publicKeyEncoding: {
    type: 'spki',
    format: 'pem',
  },
  privateKeyEncoding: {
    type: 'pkcs8',
    format: 'pem',
  },
});

// Write keys to files
const privateKeyPath = join(KEYS_DIR, 'jwt-private-key.pem');
const publicKeyPath = join(KEYS_DIR, 'jwt-public-key.pem');

writeFileSync(privateKeyPath, privateKey);
writeFileSync(publicKeyPath, publicKey);

// Set secure permissions (Unix-like systems)
try {
  chmodSync(privateKeyPath, 0o600);
  chmodSync(publicKeyPath, 0o644);
} catch (error) {
  // Ignore chmod errors on Windows
  console.error('Error setting secure permissions:', error);
}

console.info('‚úÖ Keys generated successfully!\n');
console.info(`üìÅ Private key: ${privateKeyPath}`);
console.info(`üìÅ Public key:  ${publicKeyPath}\n`);

// Convert keys to single-line format for .env
const privateKeySingleLine = privateKey.replace(/\n/g, '\\n');
const publicKeySingleLine = publicKey.replace(/\n/g, '\\n');

// Add keys to .env file
const envFilePath = join(PROJECT_ROOT, '.env');

if (!existsSync(envFilePath)) {
  console.info('üìù Creating .env file...');
  writeFileSync(envFilePath, '');
}

// Read existing .env content
let envContent = '';
if (existsSync(envFilePath)) {
  envContent = readFileSync(envFilePath, 'utf-8');
}

// Remove existing JWT key entries if they exist
const lines = envContent.split('\n');
const filteredLines = lines.filter((line) => {
  const trimmed = line.trim();
  return !trimmed.startsWith('JWT_PRIVATE_KEY=') && !trimmed.startsWith('JWT_PUBLIC_KEY=');
});

// Reconstruct .env content without JWT keys
let newEnvContent = filteredLines.join('\n').trimEnd();

// Helper function to check if variable exists
const hasEnvVar = (varName: string): boolean => {
  return lines.some((line) => {
    const trimmed = line.trim();
    return trimmed.startsWith(`${varName}=`);
  });
};

// Add JWT configuration
if (newEnvContent && !newEnvContent.endsWith('\n')) {
  newEnvContent += '\n';
}
newEnvContent += '\n# JWT Authentication Configuration (auto-generated by generate-jwt-keys.ts)\n';
newEnvContent += `JWT_PRIVATE_KEY="${privateKeySingleLine}"\n`;
newEnvContent += `JWT_PUBLIC_KEY="${publicKeySingleLine}"\n`;

// Add other JWT-related variables if they don't exist
if (!hasEnvVar('JWT_ACCESS_TOKEN_EXPIRES_IN')) {
  newEnvContent += 'JWT_ACCESS_TOKEN_EXPIRES_IN=15m\n';
}
if (!hasEnvVar('JWT_REFRESH_TOKEN_EXPIRES_IN')) {
  newEnvContent += 'JWT_REFRESH_TOKEN_EXPIRES_IN=7d\n';
}
if (!hasEnvVar('AUTH_PROVIDER')) {
  newEnvContent += 'AUTH_PROVIDER=JWT\n';
}
if (!hasEnvVar('MASTER_USER_USERNAME')) {
  newEnvContent += 'MASTER_USER_USERNAME=admin\n';
}
if (!hasEnvVar('MASTER_USER_PASSWORD')) {
  newEnvContent += 'MASTER_USER_PASSWORD=ChangeMe123!\n';
}

// Write updated .env
writeFileSync(envFilePath, newEnvContent);

console.info('‚úÖ Keys and JWT configuration added to .env file!\n');
console.info('‚ö†Ô∏è  IMPORTANT:');
console.info('   1. Keep the private key secure and never commit it to version control');
console.info('   2. The "keys/" directory is already in .gitignore');
console.info('   3. Make sure .env is in your .gitignore (it should be)');
console.info(
  '   4. Review the .env file and adjust JWT_ACCESS_TOKEN_EXPIRES_IN and JWT_REFRESH_TOKEN_EXPIRES_IN if needed',
);
console.info('');
