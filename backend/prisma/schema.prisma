generator client {
  provider        = "prisma-client"
  output          = "./client"
  previewFeatures = ["typedSql"]
  runtime         = "bun"
}

datasource db {
  provider = "postgresql"
}

model Tenant {
  id        String    @id @default(uuid()) @db.Uuid
  name      String
  createdBy String
  createdAt DateTime  @default(now())
  updatedBy String?
  updatedAt DateTime  @updatedAt
  deletedBy String?
  deletedAt DateTime?

  accounts      Account[]
  ledgerEntries LedgerEntry[]
  profiles      Profile[]

  @@index([deletedAt])
  @@map("tenants")
}

model Account {
  id        String    @id @default(uuid()) @db.Uuid
  tenantId  String    @db.Uuid
  name      String
  balance   Decimal   @default(0) @db.Decimal(18, 2)
  createdBy String
  createdAt DateTime  @default(now())
  updatedBy String?
  updatedAt DateTime  @updatedAt
  deletedBy String?
  deletedAt DateTime?

  tenant                Tenant         @relation(fields: [tenantId], references: [id])
  fromLedgerEntries     LedgerEntry[] @relation("FromAccount")
  toLedgerEntries       LedgerEntry[] @relation("ToAccount")

  @@index([tenantId])
  @@index([deletedAt])
  @@map("accounts")
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  TRANSFER
}

enum LedgerEntryStatus {
  PENDING
  COMPLETED
  FAILED
}

model LedgerEntry {
  id            String            @id @default(uuid()) @db.Uuid
  tenantId     String            @db.Uuid
  fromAccountId String?          @db.Uuid
  toAccountId  String?           @db.Uuid
  amount       Decimal            @db.Decimal(18, 2)
  type         TransactionType
  status       LedgerEntryStatus  @default(PENDING)
  createdBy   String
  createdAt   DateTime           @default(now())
  updatedBy   String?
  updatedAt   DateTime           @updatedAt
  deletedBy   String?
  deletedAt   DateTime?

  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  fromAccount Account? @relation("FromAccount", fields: [fromAccountId], references: [id])
  toAccount   Account? @relation("ToAccount", fields: [toAccountId], references: [id])

  @@index([tenantId])
  @@index([fromAccountId])
  @@index([toAccountId])
  @@index([status])
  @@index([createdAt])
  @@index([deletedAt])
  @@map("ledger_entries")
}

model User {
  id          String    @id @default(uuid()) @db.Uuid
  username    String    @unique
  passwordHash String
  isMaster   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  profiles      Profile[]
  refreshTokens RefreshToken[]

  @@index([username])
  @@index([deletedAt])
  @@map("users")
}

model Profile {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  tenantId  String   @db.Uuid
  firstName String
  lastName  String
  email     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?

  user   User   @relation(fields: [userId], references: [id])
  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([userId, tenantId])
  @@index([userId])
  @@index([tenantId])
  @@index([deletedAt])
  @@map("profiles")
}

model RefreshToken {
  id        String   @id @default(uuid()) @db.Uuid
  token     String   @unique
  userId    String   @db.Uuid
  expiresAt DateTime
  createdAt DateTime @default(now())
  revokedAt DateTime?

  user User @relation(fields: [userId], references: [id])

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

